# =============================================================================
# Kubernetes Resources - Apply after AKS is created
# =============================================================================
# Run: terraform apply -target=module.aks first
# Then: terraform apply to deploy these resources
# =============================================================================

# -----------------------------------------------------------------------------
# Kubernetes Provider Configuration
# -----------------------------------------------------------------------------

provider "kubernetes" {
  host                   = try(module.aks.kube_admin_host, "")
  client_certificate     = try(base64decode(module.aks.kube_admin_client_certificate), "")
  client_key             = try(base64decode(module.aks.kube_admin_client_key), "")
  cluster_ca_certificate = try(base64decode(module.aks.kube_admin_cluster_ca_certificate), "")
}

provider "helm" {
  kubernetes {
    host                   = try(module.aks.kube_admin_host, "")
    client_certificate     = try(base64decode(module.aks.kube_admin_client_certificate), "")
    client_key             = try(base64decode(module.aks.kube_admin_client_key), "")
    cluster_ca_certificate = try(base64decode(module.aks.kube_admin_cluster_ca_certificate), "")
  }
}

# -----------------------------------------------------------------------------
# Kubernetes Namespace
# -----------------------------------------------------------------------------

resource "kubernetes_namespace" "app" {
  count = try(module.aks.cluster_id, null) != null ? 1 : 0

  metadata {
    name = "creatorbridge"
    labels = {
      environment = local.environment
      project     = local.project
    }
  }
  depends_on = [module.aks]
}

# -----------------------------------------------------------------------------
# Kubernetes ConfigMap for App Configuration
# -----------------------------------------------------------------------------

resource "kubernetes_config_map" "app_config" {
  count = try(module.aks.cluster_id, null) != null ? 1 : 0

  metadata {
    name      = "app-config"
    namespace = kubernetes_namespace.app[0].metadata[0].name
  }

  data = {
    NODE_ENV        = "staging"
    DATABASE_HOST   = module.postgresql.server_fqdn
    DATABASE_NAME   = "creatorbridge"
    REDIS_HOST      = azurerm_redis_cache.main.hostname
    STORAGE_ACCOUNT = azurerm_storage_account.main.name
    APPINSIGHTS_KEY = azurerm_application_insights.main.instrumentation_key
  }
}

# -----------------------------------------------------------------------------
# Kubernetes Secrets for Sensitive Configuration
# -----------------------------------------------------------------------------

resource "kubernetes_secret" "app_secrets" {
  count = try(module.aks.cluster_id, null) != null ? 1 : 0

  metadata {
    name      = "app-secrets"
    namespace = kubernetes_namespace.app[0].metadata[0].name
  }

  data = {
    DATABASE_PASSWORD = var.db_admin_password
    REDIS_PASSWORD    = azurerm_redis_cache.main.primary_access_key
    STORAGE_KEY       = azurerm_storage_account.main.primary_access_key
    JWT_SECRET        = random_password.jwt_secret.result
  }
}

# -----------------------------------------------------------------------------
# NGINX Ingress Controller via Helm
# -----------------------------------------------------------------------------

resource "helm_release" "nginx_ingress" {
  count = try(module.aks.cluster_id, null) != null ? 1 : 0

  name             = "ingress-nginx"
  repository       = "https://kubernetes.github.io/ingress-nginx"
  chart            = "ingress-nginx"
  namespace        = "ingress-nginx"
  create_namespace = true
  version          = "4.8.3"

  set {
    name  = "controller.service.annotations.service\\.beta\\.kubernetes\\.io/azure-load-balancer-health-probe-request-path"
    value = "/healthz"
  }

  set {
    name  = "controller.replicaCount"
    value = "2"
  }

  depends_on = [module.aks]
}

# -----------------------------------------------------------------------------
# API Gateway Deployment
# -----------------------------------------------------------------------------

resource "kubernetes_deployment" "api_gateway" {
  count = try(module.aks.cluster_id, null) != null ? 1 : 0

  metadata {
    name      = "api-gateway"
    namespace = kubernetes_namespace.app[0].metadata[0].name
    labels = {
      app = "api-gateway"
    }
  }

  spec {
    replicas = 2

    selector {
      match_labels = {
        app = "api-gateway"
      }
    }

    template {
      metadata {
        labels = {
          app = "api-gateway"
        }
      }

      spec {
        container {
          name  = "api-gateway"
          image = "nginx:alpine"

          port {
            container_port = 80
          }

          env_from {
            config_map_ref {
              name = kubernetes_config_map.app_config[0].metadata[0].name
            }
          }

          resources {
            limits = {
              cpu    = "500m"
              memory = "512Mi"
            }
            requests = {
              cpu    = "100m"
              memory = "128Mi"
            }
          }

          liveness_probe {
            http_get {
              path = "/"
              port = 80
            }
            initial_delay_seconds = 30
            period_seconds        = 10
          }
        }
      }
    }
  }
}

resource "kubernetes_service" "api_gateway" {
  count = try(module.aks.cluster_id, null) != null ? 1 : 0

  metadata {
    name      = "api-gateway"
    namespace = kubernetes_namespace.app[0].metadata[0].name
  }

  spec {
    selector = {
      app = "api-gateway"
    }

    port {
      port        = 80
      target_port = 80
    }

    type = "ClusterIP"
  }
}

resource "kubernetes_ingress_v1" "api_gateway" {
  count = try(module.aks.cluster_id, null) != null ? 1 : 0

  metadata {
    name      = "api-gateway-ingress"
    namespace = kubernetes_namespace.app[0].metadata[0].name
    annotations = {
      "kubernetes.io/ingress.class"                  = "nginx"
      "nginx.ingress.kubernetes.io/ssl-redirect"     = "false"
      "nginx.ingress.kubernetes.io/proxy-body-size"  = "50m"
    }
  }

  spec {
    rule {
      http {
        path {
          path      = "/"
          path_type = "Prefix"
          backend {
            service {
              name = kubernetes_service.api_gateway[0].metadata[0].name
              port {
                number = 80
              }
            }
          }
        }
      }
    }
  }

  depends_on = [helm_release.nginx_ingress]
}

# -----------------------------------------------------------------------------
# Output: Ingress IP (available after deployment)
# -----------------------------------------------------------------------------

data "kubernetes_service" "ingress_nginx" {
  count = try(module.aks.cluster_id, null) != null ? 1 : 0

  metadata {
    name      = "ingress-nginx-controller"
    namespace = "ingress-nginx"
  }
  depends_on = [helm_release.nginx_ingress]
}

output "ingress_ip" {
  description = "Public IP of the NGINX Ingress Controller"
  value       = try(data.kubernetes_service.ingress_nginx[0].status[0].load_balancer[0].ingress[0].ip, "pending")
}
